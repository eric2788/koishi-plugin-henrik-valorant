// tslint:disable
/**
 * 
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import { Configuration } from "./configuration";
import isomorphicFetch, { Response } from 'node-fetch'

const BASE_PATH = "https://api.henrikdev.xyz".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Affinities {
    Eu = 'eu',
    Na = 'na',
    Latam = 'latam',
    Br = 'br',
    Ap = 'ap',
    Kr = 'kr'
}
/**
 * 
 * @export
 * @interface BundleParsed
 */
export interface BundleParsed {
    /**
     * 
     * @type {string}
     * @memberof BundleParsed
     */
    bundleUuid?: string;
    /**
     * 
     * @type {number}
     * @memberof BundleParsed
     */
    secondsRemaining?: number;
    /**
     * 
     * @type {number}
     * @memberof BundleParsed
     */
    bundlePrice?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BundleParsed
     */
    wholeSaleOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BundleParsed
     */
    expiresAt?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof BundleParsed
     */
    items?: Array<any>;
}
/**
 * 
 * @export
 * @interface BundleRaw
 */
export interface BundleRaw {
    /**
     * 
     * @type {string}
     * @memberof BundleRaw
     */
    ID?: string;
    /**
     * 
     * @type {string}
     * @memberof BundleRaw
     */
    dataAssetID?: string;
    /**
     * 
     * @type {string}
     * @memberof BundleRaw
     */
    currencyID?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof BundleRaw
     */
    items?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof BundleRaw
     */
    durationRemainingInSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BundleRaw
     */
    wholesaleonly?: boolean;
}
/**
 * 
 * @export
 * @interface BySeason
 */
export interface BySeason {
    /**
     * 
     * @type {boolean}
     * @memberof BySeason
     */
    error?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BySeason
     */
    wins?: number;
    /**
     * 
     * @type {number}
     * @memberof BySeason
     */
    numberOfGames?: number;
    /**
     * 
     * @type {number}
     * @memberof BySeason
     */
    finalRank?: number;
    /**
     * 
     * @type {string}
     * @memberof BySeason
     */
    finalRankPatched?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof BySeason
     */
    actRankWins?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof BySeason
     */
    old?: boolean;
}
/**
 * 
 * @export
 * @interface Coach
 */
export interface Coach {
    /**
     * 
     * @type {string}
     * @memberof Coach
     */
    puuid?: string;
    /**
     * 
     * @type {string}
     * @memberof Coach
     */
    team?: string;
}
/**
 * 
 * @export
 */
export type Content = Array<any>
/**
 * 
 * @export
 */
export type Leaderboard = Array<any>
/**
 * 
 * @export
 * @enum {string}
 */
export enum Maps {
    Ascent = <any> 'Ascent',
    Split = <any> 'Split',
    Fracture = <any> 'Fracture',
    Bind = <any> 'Bind',
    Breeze = <any> 'Breeze',
    District = <any> 'District',
    Kasbah = <any> 'Kasbah',
    Piazza = <any> 'Piazza',
    Lotus = <any> 'Lotus',
    Pearl = <any> 'Pearl',
    Icebox = <any> 'Icebox',
    Haven = <any> 'Haven'
}
/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * 
     * @type {any}
     * @memberof Match
     */
    metadata?: any;
    /**
     * 
     * @type {any}
     * @memberof Match
     */
    players?: any;
    /**
     * 
     * @type {Array<Observer>}
     * @memberof Match
     */
    observers?: Array<Observer>;
    /**
     * 
     * @type {Array<Coach>}
     * @memberof Match
     */
    coaches?: Array<Coach>;
    /**
     * 
     * @type {any}
     * @memberof Match
     */
    teams?: any;
    /**
     * 
     * @type {Array<any>}
     * @memberof Match
     */
    rounds?: Array<any>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModeIds {
    Competitive = <any> 'competitive',
    Custom = <any> 'custom',
    Deathmatch = <any> 'deathmatch',
    Ggteam = <any> 'ggteam',
    Hurm = <any> 'hurm',
    Newmap = <any> 'newmap',
    Onefa = <any> 'onefa',
    Snowball = <any> 'snowball',
    Spikerush = <any> 'spikerush',
    Swiftplay = <any> 'swiftplay',
    Unrated = <any> 'unrated'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Modes {
    Competitive = <any> 'Competitive',
    CustomGame = <any> 'Custom Game',
    Deathmatch = <any> 'Deathmatch',
    Escalation = <any> 'Escalation',
    TeamDeathmatch = <any> 'Team Deathmatch',
    NewMap = <any> 'New Map',
    Replication = <any> 'Replication',
    SnowballFight = <any> 'Snowball Fight',
    SpikeRush = <any> 'Spike Rush',
    Swiftplay = <any> 'Swiftplay',
    Unrated = <any> 'Unrated'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModesApi {
    Competitive = <any> 'competitive',
    Custom = <any> 'custom',
    Deathmatch = <any> 'deathmatch',
    Escalation = <any> 'escalation',
    Teamdeathmatch = <any> 'teamdeathmatch',
    Newmap = <any> 'newmap',
    Replication = <any> 'replication',
    Snowballfight = <any> 'snowballfight',
    Spikerush = <any> 'spikerush',
    Swiftplay = <any> 'swiftplay',
    Unrated = <any> 'unrated'
}
/**
 * 
 * @export
 * @interface Observer
 */
export interface Observer {
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    puuid?: string;
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    tag?: string;
    /**
     * 
     * @type {any}
     * @memberof Observer
     */
    platform?: any;
    /**
     * 
     * @type {any}
     * @memberof Observer
     */
    sessionPlaytime?: any;
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    team?: string;
    /**
     * 
     * @type {number}
     * @memberof Observer
     */
    level?: number;
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    playerCard?: string;
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    playerTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof Observer
     */
    partyId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Platforms {
    PC = <any> 'PC',
    Console = <any> 'Console'
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    puuid?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    team?: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    level?: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    character?: string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    currenttier?: number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    currenttierPatched?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    playerCard?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    playerTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    partyId?: string;
    /**
     * 
     * @type {any}
     * @memberof Player
     */
    sessionPlaytime?: any;
    /**
     * 
     * @type {any}
     * @memberof Player
     */
    assets?: any;
    /**
     * 
     * @type {any}
     * @memberof Player
     */
    behaviour?: any;
    /**
     * 
     * @type {any}
     * @memberof Player
     */
    platform?: any;
    /**
     * 
     * @type {any}
     * @memberof Player
     */
    abilityCasts?: any;
    /**
     * 
     * @type {any}
     * @memberof Player
     */
    stats?: any;
    /**
     * 
     * @type {any}
     * @memberof Player
     */
    economy?: any;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    damageMade?: number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    damageReceived?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PremierConferences {
    EUCENTRALEAST = <any> 'EU_CENTRAL_EAST',
    EUWEST = <any> 'EU_WEST',
    EUMIDDLEEAST = <any> 'EU_MIDDLE_EAST',
    EUTURKEY = <any> 'EU_TURKEY',
    NAUSEAST = <any> 'NA_US_EAST',
    NAUSWEST = <any> 'NA_US_WEST',
    LATAMNORTH = <any> 'LATAM_NORTH',
    LATAMSOUTH = <any> 'LATAM_SOUTH',
    BRBRAZIL = <any> 'BR_BRAZIL',
    KRKOREA = <any> 'KR_KOREA',
    APASIA = <any> 'AP_ASIA',
    APJAPAN = <any> 'AP_JAPAN',
    APOCEANIA = <any> 'AP_OCEANIA',
    APSOUTHASIA = <any> 'AP_SOUTH_ASIA'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PremierSeasonsEventMapSelectionTypes {
    RANDOM = <any> 'RANDOM',
    PICKBAN = <any> 'PICKBAN'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PremierSeasonsEventTypes {
    LEAGUE = <any> 'LEAGUE',
    TOURNAMENT = <any> 'TOURNAMENT'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Regions {
    Eu = <any> 'eu',
    Na = <any> 'na',
    Ap = <any> 'ap',
    Kr = <any> 'kr'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Seasons {
    E1a1 = <any> 'e1a1',
    E1a2 = <any> 'e1a2',
    E1a3 = <any> 'e1a3',
    E2a1 = <any> 'e2a1',
    E2a2 = <any> 'e2a2',
    E2a3 = <any> 'e2a3',
    E3a1 = <any> 'e3a1',
    E3a2 = <any> 'e3a2',
    E3a3 = <any> 'e3a3',
    E4a1 = <any> 'e4a1',
    E4a2 = <any> 'e4a2',
    E4a3 = <any> 'e4a3',
    E5a1 = <any> 'e5a1',
    E5a2 = <any> 'e5a2',
    E5a3 = <any> 'e5a3',
    E6a1 = <any> 'e6a1',
    E6a2 = <any> 'e6a2',
    E6a3 = <any> 'e6a3',
    E7a1 = <any> 'e7a1',
    E7a2 = <any> 'e7a2',
    E7a3 = <any> 'e7a3'
}
/**
 * 
 * @export
 */
export type Status = Array<any>
/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {boolean}
     * @memberof Team
     */
    hasWon?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    roundsWon?: number;
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    roundsLost?: number;
    /**
     * 
     * @type {any}
     * @memberof Team
     */
    roaster?: any;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Tiers {
    Unrated = <any> 'Unrated',
    Unknown1 = <any> 'Unknown 1',
    Unknown2 = <any> 'Unknown 2',
    Iron1 = <any> 'Iron 1',
    Iron2 = <any> 'Iron 2',
    Iron3 = <any> 'Iron 3',
    Bronze1 = <any> 'Bronze 1',
    Bronze2 = <any> 'Bronze 2',
    Bronze3 = <any> 'Bronze 3',
    Silver1 = <any> 'Silver 1',
    Silver2 = <any> 'Silver 2',
    Silver3 = <any> 'Silver 3',
    Gold1 = <any> 'Gold 1',
    Gold2 = <any> 'Gold 2',
    Gold3 = <any> 'Gold 3',
    Platinum1 = <any> 'Platinum 1',
    Platinum2 = <any> 'Platinum 2',
    Platinum3 = <any> 'Platinum 3',
    Diamond1 = <any> 'Diamond 1',
    Diamond2 = <any> 'Diamond 2',
    Diamond3 = <any> 'Diamond 3',
    Ascendant1 = <any> 'Ascendant 1',
    Ascendant2 = <any> 'Ascendant 2',
    Ascendant3 = <any> 'Ascendant 3',
    Immortal1 = <any> 'Immortal 1',
    Immortal2 = <any> 'Immortal 2',
    Immortal3 = <any> 'Immortal 3',
    Radiant = <any> 'Radiant'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TiersOld {
    Unrated = <any> 'Unrated',
    Unknown1 = <any> 'Unknown 1',
    Unknown2 = <any> 'Unknown 2',
    Iron1 = <any> 'Iron 1',
    Iron2 = <any> 'Iron 2',
    Iron3 = <any> 'Iron 3',
    Bronze1 = <any> 'Bronze 1',
    Bronze2 = <any> 'Bronze 2',
    Bronze3 = <any> 'Bronze 3',
    Silver1 = <any> 'Silver 1',
    Silver2 = <any> 'Silver 2',
    Silver3 = <any> 'Silver 3',
    Gold1 = <any> 'Gold 1',
    Gold2 = <any> 'Gold 2',
    Gold3 = <any> 'Gold 3',
    Platinum1 = <any> 'Platinum 1',
    Platinum2 = <any> 'Platinum 2',
    Platinum3 = <any> 'Platinum 3',
    Diamond1 = <any> 'Diamond 1',
    Diamond2 = <any> 'Diamond 2',
    Diamond3 = <any> 'Diamond 3',
    Immortal1 = <any> 'Immortal 1',
    Immortal2 = <any> 'Immortal 2',
    Immortal3 = <any> 'Immortal 3',
    Radiant = <any> 'Radiant'
}
/**
 * 
 * @export
 * @interface V1Account
 */
export interface V1Account {
    /**
     * 
     * @type {number}
     * @memberof V1Account
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof V1Account
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface V1LifetimeMatches
 */
export interface V1LifetimeMatches {
    /**
     * 
     * @type {number}
     * @memberof V1LifetimeMatches
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof V1LifetimeMatches
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1LifetimeMatches
     */
    tag?: string;
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMatches
     */
    results?: any;
    /**
     * 
     * @type {Array<V1LifetimeMatchesItem>}
     * @memberof V1LifetimeMatches
     */
    data?: Array<V1LifetimeMatchesItem>;
}
/**
 * 
 * @export
 * @interface V1LifetimeMatchesItem
 */
export interface V1LifetimeMatchesItem {
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMatchesItem
     */
    meta?: any;
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMatchesItem
     */
    stats?: any;
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMatchesItem
     */
    teams?: any;
}
/**
 * 
 * @export
 * @interface V1LifetimeMmrHistory
 */
export interface V1LifetimeMmrHistory {
    /**
     * 
     * @type {number}
     * @memberof V1LifetimeMmrHistory
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof V1LifetimeMmrHistory
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1LifetimeMmrHistory
     */
    tag?: string;
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMmrHistory
     */
    results?: any;
    /**
     * 
     * @type {Array<V1LifetimeMmrHistoryItem>}
     * @memberof V1LifetimeMmrHistory
     */
    data?: Array<V1LifetimeMmrHistoryItem>;
}
/**
 * 
 * @export
 * @interface V1LifetimeMmrHistoryItem
 */
export interface V1LifetimeMmrHistoryItem {
    /**
     * 
     * @type {string}
     * @memberof V1LifetimeMmrHistoryItem
     */
    match_id?: string;
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMmrHistoryItem
     */
    tier?: any;
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMmrHistoryItem
     */
    map?: any;
    /**
     * 
     * @type {any}
     * @memberof V1LifetimeMmrHistoryItem
     */
    season?: any;
    /**
     * 
     * @type {number}
     * @memberof V1LifetimeMmrHistoryItem
     */
    ranking_in_tier?: number;
    /**
     * 
     * @type {number}
     * @memberof V1LifetimeMmrHistoryItem
     */
    last_mmr_change?: number;
    /**
     * 
     * @type {number}
     * @memberof V1LifetimeMmrHistoryItem
     */
    elo?: number;
    /**
     * 
     * @type {Date}
     * @memberof V1LifetimeMmrHistoryItem
     */
    date?: Date;
}
/**
 * 
 * @export
 * @interface V1PartialPremierTeam
 */
export interface V1PartialPremierTeam {
    /**
     * 
     * @type {string}
     * @memberof V1PartialPremierTeam
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PartialPremierTeam
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PartialPremierTeam
     */
    tag?: string;
    /**
     * 
     * @type {PremierConferences}
     * @memberof V1PartialPremierTeam
     */
    conference?: PremierConferences;
    /**
     * 
     * @type {number}
     * @memberof V1PartialPremierTeam
     */
    division?: number;
    /**
     * 
     * @type {Affinities}
     * @memberof V1PartialPremierTeam
     */
    affinity?: Affinities;
    /**
     * 
     * @type {Regions}
     * @memberof V1PartialPremierTeam
     */
    region?: Regions;
    /**
     * 
     * @type {number}
     * @memberof V1PartialPremierTeam
     */
    losses?: number;
    /**
     * 
     * @type {number}
     * @memberof V1PartialPremierTeam
     */
    wins?: number;
    /**
     * 
     * @type {number}
     * @memberof V1PartialPremierTeam
     */
    score?: number;
    /**
     * 
     * @type {number}
     * @memberof V1PartialPremierTeam
     */
    ranking?: number;
    /**
     * 
     * @type {any}
     * @memberof V1PartialPremierTeam
     */
    customization?: any;
}
/**
 * 
 * @export
 * @interface V1PremierConference
 */
export interface V1PremierConference {
    /**
     * 
     * @type {number}
     * @memberof V1PremierConference
     */
    status?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1PremierConference
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface V1PremierLeaderboard
 */
export interface V1PremierLeaderboard {
    /**
     * 
     * @type {number}
     * @memberof V1PremierLeaderboard
     */
    status?: number;
    /**
     * 
     * @type {Array<V1PartialPremierTeam>}
     * @memberof V1PremierLeaderboard
     */
    data?: Array<V1PartialPremierTeam>;
}
/**
 * 
 * @export
 * @interface V1PremierSearch
 */
export interface V1PremierSearch {
    /**
     * 
     * @type {number}
     * @memberof V1PremierSearch
     */
    status?: number;
    /**
     * 
     * @type {Array<V1PartialPremierTeam>}
     * @memberof V1PremierSearch
     */
    data?: Array<V1PartialPremierTeam>;
}
/**
 * 
 * @export
 * @interface V1PremierSeason
 */
export interface V1PremierSeason {
    /**
     * 
     * @type {number}
     * @memberof V1PremierSeason
     */
    status?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1PremierSeason
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface V1PremierTeam
 */
export interface V1PremierTeam {
    /**
     * 
     * @type {number}
     * @memberof V1PremierTeam
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof V1PremierTeam
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface V1PremierTeamHistory
 */
export interface V1PremierTeamHistory {
    /**
     * 
     * @type {number}
     * @memberof V1PremierTeamHistory
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof V1PremierTeamHistory
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface V1QueueStatus
 */
export interface V1QueueStatus {
    /**
     * 
     * @type {number}
     * @memberof V1QueueStatus
     */
    status?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1QueueStatus
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface V1esportschedule
 */
export interface V1esportschedule {
    /**
     * 
     * @type {number}
     * @memberof V1esportschedule
     */
    status?: number;
    /**
     * 
     * @type {Array<V1esportscheduleitem>}
     * @memberof V1esportschedule
     */
    data?: Array<V1esportscheduleitem>;
}
/**
 * 
 * @export
 * @interface V1esportscheduleitem
 */
export interface V1esportscheduleitem {
    /**
     * 
     * @type {string}
     * @memberof V1esportscheduleitem
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof V1esportscheduleitem
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof V1esportscheduleitem
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1esportscheduleitem
     */
    vod?: string;
    /**
     * 
     * @type {any}
     * @memberof V1esportscheduleitem
     */
    league?: any;
    /**
     * 
     * @type {any}
     * @memberof V1esportscheduleitem
     */
    tournament?: any;
    /**
     * 
     * @type {any}
     * @memberof V1esportscheduleitem
     */
    match?: any;
}
/**
 * 
 * @export
 */
export type V1leaderboard = Leaderboard
/**
 * 
 * @export
 * @interface V1mmr
 */
export interface V1mmr {
    /**
     * 
     * @type {number}
     * @memberof V1mmr
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof V1mmr
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface V1mmrh
 */
export interface V1mmrh {
    /**
     * 
     * @type {number}
     * @memberof V1mmrh
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof V1mmrh
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1mmrh
     */
    tag?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1mmrh
     */
    data?: Array<any>;
}
/**
 * 
 * @export
 * @interface V1storefeatured
 */
export interface V1storefeatured {
    /**
     * 
     * @type {number}
     * @memberof V1storefeatured
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof V1storefeatured
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface V2leaderboard
 */
export interface V2leaderboard {
    /**
     * 
     * @type {number}
     * @memberof V2leaderboard
     */
    lastUpdate?: number;
    /**
     * 
     * @type {number}
     * @memberof V2leaderboard
     */
    nextUpdate?: number;
    /**
     * 
     * @type {number}
     * @memberof V2leaderboard
     */
    totalPlayers?: number;
    /**
     * 
     * @type {number}
     * @memberof V2leaderboard
     */
    radiantThreshold?: number;
    /**
     * 
     * @type {number}
     * @memberof V2leaderboard
     */
    immortal3Threshold?: number;
    /**
     * 
     * @type {number}
     * @memberof V2leaderboard
     */
    immortal2Threshold?: number;
    /**
     * 
     * @type {number}
     * @memberof V2leaderboard
     */
    immortal1Threshold?: number;
    /**
     * 
     * @type {Leaderboard}
     * @memberof V2leaderboard
     */
    players?: Leaderboard;
}
/**
 * 
 * @export
 * @interface V2mmr
 */
export interface V2mmr {
    /**
     * 
     * @type {number}
     * @memberof V2mmr
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof V2mmr
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface V2storefeatured
 */
export interface V2storefeatured {
    /**
     * 
     * @type {number}
     * @memberof V2storefeatured
     */
    status?: number;
    /**
     * 
     * @type {Array<BundleParsed>}
     * @memberof V2storefeatured
     */
    data?: Array<BundleParsed>;
}
/**
 * 
 * @export
 * @interface V2storeoffer
 */
export interface V2storeoffer {
    /**
     * 
     * @type {string}
     * @memberof V2storeoffer
     */
    offerId?: string;
    /**
     * 
     * @type {number}
     * @memberof V2storeoffer
     */
    cost?: number;
    /**
     * 
     * @type {string}
     * @memberof V2storeoffer
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2storeoffer
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof V2storeoffer
     */
    type?: V2storeoffer.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof V2storeoffer
     */
    skinId?: string;
    /**
     * 
     * @type {any}
     * @memberof V2storeoffer
     */
    contentTier?: any;
}

/**
 * @export
 * @namespace V2storeoffer
 */
export namespace V2storeoffer {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SkinLevel = <any> 'skin_level',
        SkinChroma = <any> 'skin_chroma',
        Buddy = <any> 'buddy',
        Spray = <any> 'spray',
        PlayerCard = <any> 'player_card',
        PlayerTitle = <any> 'player_title'
    }
}
/**
 * 
 * @export
 * @interface V2storeoffers
 */
export interface V2storeoffers {
    /**
     * 
     * @type {number}
     * @memberof V2storeoffers
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof V2storeoffers
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface V3matches
 */
export interface V3matches {
    /**
     * 
     * @type {string}
     * @memberof V3matches
     */
    status?: string;
    /**
     * 
     * @type {Array<Match>}
     * @memberof V3matches
     */
    data?: Array<Match>;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get account details
         * @param {string} name 
         * @param {string} tag 
         * @param {boolean} [force] Force data update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1AccountNameTagGet(name: string, tag: string, force?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling valorantV1AccountNameTagGet.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling valorantV1AccountNameTagGet.');
            }
            const localVarPath = `/valorant/v1/account/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account details
         * @param {string} puuid 
         * @param {boolean} [force] Force data update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidAccountPuuidGet(puuid: string, force?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'puuid' is not null or undefined
            if (puuid === null || puuid === undefined) {
                throw new RequiredError('puuid','Required parameter puuid was null or undefined when calling valorantV1ByPuuidAccountPuuidGet.');
            }
            const localVarPath = `/valorant/v1/by-puuid/account/{puuid}`
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lifetime matches
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet.');
            }
            // verify required parameter 'puuid' is not null or undefined
            if (puuid === null || puuid === undefined) {
                throw new RequiredError('puuid','Required parameter puuid was null or undefined when calling valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet.');
            }
            const localVarPath = `/valorant/v1/by-puuid/lifetime/matches/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lifetime mmr history
         * @param {Affinities} region Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of mmr changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet(region: Affinities, puuid: string, page?: number, size?: number, options: any = {}): FetchArgs {
            // verify required parameter 'region' is not null or undefined
            if (region === null || region === undefined) {
                throw new RequiredError('region','Required parameter region was null or undefined when calling valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet.');
            }
            // verify required parameter 'puuid' is not null or undefined
            if (puuid === null || puuid === undefined) {
                throw new RequiredError('puuid','Required parameter puuid was null or undefined when calling valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet.');
            }
            const localVarPath = `/valorant/v1/by-puuid/lifetime/mmr-history/{region}/{puuid}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MMR Details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1ByPuuidMmrAffinityPuuidGet.');
            }
            // verify required parameter 'puuid' is not null or undefined
            if (puuid === null || puuid === undefined) {
                throw new RequiredError('puuid','Required parameter puuid was null or undefined when calling valorantV1ByPuuidMmrAffinityPuuidGet.');
            }
            const localVarPath = `/valorant/v1/by-puuid/mmr/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get mmr history
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidMmrHistoryAffinityPuuidGet(affinity: Affinities, puuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1ByPuuidMmrHistoryAffinityPuuidGet.');
            }
            // verify required parameter 'puuid' is not null or undefined
            if (puuid === null || puuid === undefined) {
                throw new RequiredError('puuid','Required parameter puuid was null or undefined when calling valorantV1ByPuuidMmrHistoryAffinityPuuidGet.');
            }
            const localVarPath = `/valorant/v1/by-puuid/mmr-history/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get content
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ContentGet(locale?: string, options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/content`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Outputs a 1024x1024 pixel image of the requested crosshair
         * @param {string} [id] ID of the crosshair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1CrosshairGenerateGet(id?: string, options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/crosshair/generate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns esports schedule data
         * @param {string} [region] region of the game (multiple possible)
         * @param {string} [league] league of the game (multiple possible, these also can be highly dynamic if riot announces new tournaments/leagues)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1EsportsScheduleGet(region?: string, league?: string, options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/esports/schedule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (league !== undefined) {
                localVarQueryParameter['league'] = league;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Leaderboard
         * @param {Affinities} affinity 
         * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {Seasons} [season] Returns the leaderboard for a specific season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1LeaderboardAffinityGet.');
            }
            const localVarPath = `/valorant/v1/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (puuid !== undefined) {
                localVarQueryParameter['puuid'] = puuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lifetime matches
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} name 
         * @param {string} tag 
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LifetimeMatchesAffinityNameTagGet(affinity: Affinities, name: string, tag: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1LifetimeMatchesAffinityNameTagGet.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling valorantV1LifetimeMatchesAffinityNameTagGet.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling valorantV1LifetimeMatchesAffinityNameTagGet.');
            }
            const localVarPath = `/valorant/v1/lifetime/matches/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lifetime mmr changes
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} name 
         * @param {string} tag 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned mmr changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LifetimeMmrHistoryAffinityNameTagGet(affinity: Affinities, name: string, tag: string, page?: number, size?: number, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1LifetimeMmrHistoryAffinityNameTagGet.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling valorantV1LifetimeMmrHistoryAffinityNameTagGet.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling valorantV1LifetimeMmrHistoryAffinityNameTagGet.');
            }
            const localVarPath = `/valorant/v1/lifetime/mmr-history/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get mmr details
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling valorantV1MmrAffinityNameTagGet.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling valorantV1MmrAffinityNameTagGet.');
            }
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1MmrAffinityNameTagGet.');
            }
            const localVarPath = `/valorant/v1/mmr/{affinity}/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MMR History
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1MmrHistoryAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling valorantV1MmrHistoryAffinityNameTagGet.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling valorantV1MmrHistoryAffinityNameTagGet.');
            }
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1MmrHistoryAffinityNameTagGet.');
            }
            const localVarPath = `/valorant/v1/mmr-history/{affinity}/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all premier conferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierConferencesGet(options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/premier/conferences`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a combined leaderboard in the conference, sorted by ranking in that div
         * @param {Affinities} affinity 
         * @param {PremierConferences} conference 
         * @param {number} division 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityConferenceDivisionGet(affinity: Affinities, conference: PremierConferences, division: number, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1PremierLeaderboardAffinityConferenceDivisionGet.');
            }
            // verify required parameter 'conference' is not null or undefined
            if (conference === null || conference === undefined) {
                throw new RequiredError('conference','Required parameter conference was null or undefined when calling valorantV1PremierLeaderboardAffinityConferenceDivisionGet.');
            }
            // verify required parameter 'division' is not null or undefined
            if (division === null || division === undefined) {
                throw new RequiredError('division','Required parameter division was null or undefined when calling valorantV1PremierLeaderboardAffinityConferenceDivisionGet.');
            }
            const localVarPath = `/valorant/v1/premier/leaderboard/{affinity}/{conference}/{division}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"conference"}}`, encodeURIComponent(String(conference)))
                .replace(`{${"division"}}`, encodeURIComponent(String(division)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a combined leaderboard in the conference, sorted by div and ranking
         * @param {Affinities} affinity 
         * @param {PremierConferences} conference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityConferenceGet(affinity: Affinities, conference: PremierConferences, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1PremierLeaderboardAffinityConferenceGet.');
            }
            // verify required parameter 'conference' is not null or undefined
            if (conference === null || conference === undefined) {
                throw new RequiredError('conference','Required parameter conference was null or undefined when calling valorantV1PremierLeaderboardAffinityConferenceGet.');
            }
            const localVarPath = `/valorant/v1/premier/leaderboard/{affinity}/{conference}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"conference"}}`, encodeURIComponent(String(conference)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a combined leaderboard in the affinity, sorted by div and ranking
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityGet(affinity: Affinities, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1PremierLeaderboardAffinityGet.');
            }
            const localVarPath = `/valorant/v1/premier/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for current active premier teams
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {number} [division] 
         * @param {PremierConferences} [conference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierSearchGet(name?: string, tag?: string, division?: number, conference?: PremierConferences, options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/premier/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (division !== undefined) {
                localVarQueryParameter['division'] = division;
            }

            if (conference !== undefined) {
                localVarQueryParameter['conference'] = conference;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all premier seasons
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierSeasonsAffinityGet(affinity: Affinities, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1PremierSeasonsAffinityGet.');
            }
            const localVarPath = `/valorant/v1/premier/seasons/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a premier team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamIdGet(teamId: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling valorantV1PremierTeamIdGet.');
            }
            const localVarPath = `/valorant/v1/premier/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match history of a premier team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamIdHistoryGet(teamId: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling valorantV1PremierTeamIdHistoryGet.');
            }
            const localVarPath = `/valorant/v1/premier/{team_id}/history`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a premier team
         * @param {string} teamName 
         * @param {string} teamTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamNameTeamTagGet(teamName: string, teamTag: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamName' is not null or undefined
            if (teamName === null || teamName === undefined) {
                throw new RequiredError('teamName','Required parameter teamName was null or undefined when calling valorantV1PremierTeamNameTeamTagGet.');
            }
            // verify required parameter 'teamTag' is not null or undefined
            if (teamTag === null || teamTag === undefined) {
                throw new RequiredError('teamTag','Required parameter teamTag was null or undefined when calling valorantV1PremierTeamNameTeamTagGet.');
            }
            const localVarPath = `/valorant/v1/premier/{team_name}/{team_tag}`
                .replace(`{${"team_name"}}`, encodeURIComponent(String(teamName)))
                .replace(`{${"team_tag"}}`, encodeURIComponent(String(teamTag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get match history of a premier team
         * @param {string} teamName 
         * @param {string} teamTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamNameTeamTagHistoryGet(teamName: string, teamTag: string, options: any = {}): FetchArgs {
            // verify required parameter 'teamName' is not null or undefined
            if (teamName === null || teamName === undefined) {
                throw new RequiredError('teamName','Required parameter teamName was null or undefined when calling valorantV1PremierTeamNameTeamTagHistoryGet.');
            }
            // verify required parameter 'teamTag' is not null or undefined
            if (teamTag === null || teamTag === undefined) {
                throw new RequiredError('teamTag','Required parameter teamTag was null or undefined when calling valorantV1PremierTeamNameTeamTagHistoryGet.');
            }
            const localVarPath = `/valorant/v1/premier/{team_name}/{team_tag}/history`
                .replace(`{${"team_name"}}`, encodeURIComponent(String(teamName)))
                .replace(`{${"team_tag"}}`, encodeURIComponent(String(teamTag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all available queues and their metadata
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1QueueStatusAffinityGet(affinity: Affinities, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1QueueStatusAffinityGet.');
            }
            const localVarPath = `/valorant/v1/queue-status/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get unchanged response from the valorant api
         * @param {any} body Post body to receive data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1RawPost(body: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling valorantV1RawPost.');
            }
            const localVarPath = `/valorant/v1/raw`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Server status
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StatusAffinityGet(affinity: Affinities, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV1StatusAffinityGet.');
            }
            const localVarPath = `/valorant/v1/status/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StoreFeaturedGet(options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/store-featured`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StoreOffersGet(options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/store-offers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1VersionAffinityGet(options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/version/{affinity}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1WebsiteCountryCodeGet(options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v1/website/{countryCode}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MMR Details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {Seasons} [season] Available for v2 MMR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, season?: Seasons, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV2ByPuuidMmrAffinityPuuidGet.');
            }
            // verify required parameter 'puuid' is not null or undefined
            if (puuid === null || puuid === undefined) {
                throw new RequiredError('puuid','Required parameter puuid was null or undefined when calling valorantV2ByPuuidMmrAffinityPuuidGet.');
            }
            const localVarPath = `/valorant/v2/by-puuid/mmr/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Leaderboard
         * @param {Affinities} affinity 
         * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {Seasons} [season] Returns the leaderboard for a specific season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV2LeaderboardAffinityGet.');
            }
            const localVarPath = `/valorant/v2/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (puuid !== undefined) {
                localVarQueryParameter['puuid'] = puuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Match Deatils
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2MatchMatchIdGet(matchId: string, options: any = {}): FetchArgs {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling valorantV2MatchMatchIdGet.');
            }
            const localVarPath = `/valorant/v2/match/{matchId}`
                .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get mmr details
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {Seasons} [season] Available for v2 mmr only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, season?: Seasons, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling valorantV2MmrAffinityNameTagGet.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling valorantV2MmrAffinityNameTagGet.');
            }
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV2MmrAffinityNameTagGet.');
            }
            const localVarPath = `/valorant/v2/mmr/{affinity}/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2StoreFeaturedGet(options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v2/store-featured`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2StoreOffersGet(options: any = {}): FetchArgs {
            const localVarPath = `/valorant/v2/store-offers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] Available for v3 matches
         * @param {number} [size] Available for v3 matches (how many matches should be returned)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV3ByPuuidMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, size?: number, options: any = {}): FetchArgs {
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV3ByPuuidMatchesAffinityPuuidGet.');
            }
            // verify required parameter 'puuid' is not null or undefined
            if (puuid === null || puuid === undefined) {
                throw new RequiredError('puuid','Required parameter puuid was null or undefined when calling valorantV3ByPuuidMatchesAffinityPuuidGet.');
            }
            const localVarPath = `/valorant/v3/by-puuid/matches/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Match History
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV3MatchesAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling valorantV3MatchesAffinityNameTagGet.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling valorantV3MatchesAffinityNameTagGet.');
            }
            // verify required parameter 'affinity' is not null or undefined
            if (affinity === null || affinity === undefined) {
                throw new RequiredError('affinity','Required parameter affinity was null or undefined when calling valorantV3MatchesAffinityNameTagGet.');
            }
            const localVarPath = `/valorant/v3/matches/{affinity}/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers, configuration.apiKey ? { Authorization: configuration.apiKey} : {});
            

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get account details
         * @param {string} name 
         * @param {string} tag 
         * @param {boolean} [force] Force data update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1AccountNameTagGet(name: string, tag: string, force?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Account> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1AccountNameTagGet(name, tag, force, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get account details
         * @param {string} puuid 
         * @param {boolean} [force] Force data update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidAccountPuuidGet(puuid: string, force?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Account> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1ByPuuidAccountPuuidGet(puuid, force, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get lifetime matches
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LifetimeMatches> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet(affinity, puuid, mode, map, page, size, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get lifetime mmr history
         * @param {Affinities} region Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of mmr changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet(region: Affinities, puuid: string, page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LifetimeMmrHistory> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet(region, puuid, page, size, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get MMR Details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1mmr> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1ByPuuidMmrAffinityPuuidGet(affinity, puuid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get mmr history
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidMmrHistoryAffinityPuuidGet(affinity: Affinities, puuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1mmrh> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1ByPuuidMmrHistoryAffinityPuuidGet(affinity, puuid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get content
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ContentGet(locale?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1ContentGet(locale, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Outputs a 1024x1024 pixel image of the requested crosshair
         * @param {string} [id] ID of the crosshair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1CrosshairGenerateGet(id?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1CrosshairGenerateGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.blob();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns esports schedule data
         * @param {string} [region] region of the game (multiple possible)
         * @param {string} [league] league of the game (multiple possible, these also can be highly dynamic if riot announces new tournaments/leagues)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1EsportsScheduleGet(region?: string, league?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1esportschedule> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1EsportsScheduleGet(region, league, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Leaderboard
         * @param {Affinities} affinity 
         * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {Seasons} [season] Returns the leaderboard for a specific season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1leaderboard> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1LeaderboardAffinityGet(affinity, puuid, name, tag, season, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                }).then((body) => body as V1leaderboard);
            };
        },
        /**
         * Get lifetime matches
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} name 
         * @param {string} tag 
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LifetimeMatchesAffinityNameTagGet(affinity: Affinities, name: string, tag: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LifetimeMatches> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1LifetimeMatchesAffinityNameTagGet(affinity, name, tag, mode, map, page, size, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get lifetime mmr changes
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} name 
         * @param {string} tag 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned mmr changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LifetimeMmrHistoryAffinityNameTagGet(affinity: Affinities, name: string, tag: string, page?: number, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LifetimeMmrHistory> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1LifetimeMmrHistoryAffinityNameTagGet(affinity, name, tag, page, size, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get mmr details
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1mmr> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1MmrAffinityNameTagGet(name, tag, affinity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get MMR History
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1MmrHistoryAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1mmrh> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1MmrHistoryAffinityNameTagGet(name, tag, affinity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all premier conferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierConferencesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierConference> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierConferencesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a combined leaderboard in the conference, sorted by ranking in that div
         * @param {Affinities} affinity 
         * @param {PremierConferences} conference 
         * @param {number} division 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityConferenceDivisionGet(affinity: Affinities, conference: PremierConferences, division: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierLeaderboard> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierLeaderboardAffinityConferenceDivisionGet(affinity, conference, division, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a combined leaderboard in the conference, sorted by div and ranking
         * @param {Affinities} affinity 
         * @param {PremierConferences} conference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityConferenceGet(affinity: Affinities, conference: PremierConferences, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierLeaderboard> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierLeaderboardAffinityConferenceGet(affinity, conference, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a combined leaderboard in the affinity, sorted by div and ranking
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityGet(affinity: Affinities, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierLeaderboard> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierLeaderboardAffinityGet(affinity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search for current active premier teams
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {number} [division] 
         * @param {PremierConferences} [conference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierSearchGet(name?: string, tag?: string, division?: number, conference?: PremierConferences, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierSearch> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierSearchGet(name, tag, division, conference, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all premier seasons
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierSeasonsAffinityGet(affinity: Affinities, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierSeason> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierSeasonsAffinityGet(affinity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a premier team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamIdGet(teamId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierTeam> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierTeamIdGet(teamId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get match history of a premier team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamIdHistoryGet(teamId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierTeamHistory> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierTeamIdHistoryGet(teamId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a premier team
         * @param {string} teamName 
         * @param {string} teamTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamNameTeamTagGet(teamName: string, teamTag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierTeam> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierTeamNameTeamTagGet(teamName, teamTag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get match history of a premier team
         * @param {string} teamName 
         * @param {string} teamTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamNameTeamTagHistoryGet(teamName: string, teamTag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1PremierTeamHistory> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1PremierTeamNameTeamTagHistoryGet(teamName, teamTag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all available queues and their metadata
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1QueueStatusAffinityGet(affinity: Affinities, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1QueueStatus> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1QueueStatusAffinityGet(affinity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get unchanged response from the valorant api
         * @param {any} body Post body to receive data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1RawPost(body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1RawPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Server status
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StatusAffinityGet(affinity: Affinities, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1StatusAffinityGet(affinity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StoreFeaturedGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1storefeatured> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1StoreFeaturedGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StoreOffersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1StoreOffersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1VersionAffinityGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1VersionAffinityGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1WebsiteCountryCodeGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV1WebsiteCountryCodeGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get MMR Details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {Seasons} [season] Available for v2 MMR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, season?: Seasons, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2mmr> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV2ByPuuidMmrAffinityPuuidGet(affinity, puuid, season, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Leaderboard
         * @param {Affinities} affinity 
         * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {Seasons} [season] Returns the leaderboard for a specific season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2leaderboard> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV2LeaderboardAffinityGet(affinity, puuid, name, tag, season, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Match Deatils
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2MatchMatchIdGet(matchId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV2MatchMatchIdGet(matchId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get mmr details
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {Seasons} [season] Available for v2 mmr only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, season?: Seasons, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2mmr> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV2MmrAffinityNameTagGet(name, tag, affinity, season, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2StoreFeaturedGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2storefeatured> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV2StoreFeaturedGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2StoreOffersGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2storeoffers> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV2StoreOffersGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get account details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] Available for v3 matches
         * @param {number} [size] Available for v3 matches (how many matches should be returned)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV3ByPuuidMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, size?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V3matches> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV3ByPuuidMatchesAffinityPuuidGet(affinity, puuid, mode, map, size, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Match History
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV3MatchesAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).valorantV3MatchesAffinityNameTagGet(name, tag, affinity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get account details
         * @param {string} name 
         * @param {string} tag 
         * @param {boolean} [force] Force data update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1AccountNameTagGet(name: string, tag: string, force?: boolean, options?: any) {
            return DefaultApiFp(configuration).valorantV1AccountNameTagGet(name, tag, force, options)(fetch, basePath);
        },
        /**
         * Get account details
         * @param {string} puuid 
         * @param {boolean} [force] Force data update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidAccountPuuidGet(puuid: string, force?: boolean, options?: any) {
            return DefaultApiFp(configuration).valorantV1ByPuuidAccountPuuidGet(puuid, force, options)(fetch, basePath);
        },
        /**
         * Get lifetime matches
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options?: any) {
            return DefaultApiFp(configuration).valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet(affinity, puuid, mode, map, page, size, options)(fetch, basePath);
        },
        /**
         * Get lifetime mmr history
         * @param {Affinities} region Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of mmr changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet(region: Affinities, puuid: string, page?: number, size?: number, options?: any) {
            return DefaultApiFp(configuration).valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet(region, puuid, page, size, options)(fetch, basePath);
        },
        /**
         * Get MMR Details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1ByPuuidMmrAffinityPuuidGet(affinity, puuid, options)(fetch, basePath);
        },
        /**
         * Get mmr history
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ByPuuidMmrHistoryAffinityPuuidGet(affinity: Affinities, puuid: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1ByPuuidMmrHistoryAffinityPuuidGet(affinity, puuid, options)(fetch, basePath);
        },
        /**
         * Get content
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1ContentGet(locale?: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1ContentGet(locale, options)(fetch, basePath);
        },
        /**
         * Outputs a 1024x1024 pixel image of the requested crosshair
         * @param {string} [id] ID of the crosshair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1CrosshairGenerateGet(id?: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1CrosshairGenerateGet(id, options)(fetch, basePath);
        },
        /**
         * Returns esports schedule data
         * @param {string} [region] region of the game (multiple possible)
         * @param {string} [league] league of the game (multiple possible, these also can be highly dynamic if riot announces new tournaments/leagues)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1EsportsScheduleGet(region?: string, league?: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1EsportsScheduleGet(region, league, options)(fetch, basePath);
        },
        /**
         * Get Leaderboard
         * @param {Affinities} affinity 
         * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {Seasons} [season] Returns the leaderboard for a specific season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options?: any) {
            return DefaultApiFp(configuration).valorantV1LeaderboardAffinityGet(affinity, puuid, name, tag, season, options)(fetch, basePath);
        },
        /**
         * Get lifetime matches
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} name 
         * @param {string} tag 
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LifetimeMatchesAffinityNameTagGet(affinity: Affinities, name: string, tag: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options?: any) {
            return DefaultApiFp(configuration).valorantV1LifetimeMatchesAffinityNameTagGet(affinity, name, tag, mode, map, page, size, options)(fetch, basePath);
        },
        /**
         * Get lifetime mmr changes
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} name 
         * @param {string} tag 
         * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
         * @param {number} [size] The amount of returned mmr changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1LifetimeMmrHistoryAffinityNameTagGet(affinity: Affinities, name: string, tag: string, page?: number, size?: number, options?: any) {
            return DefaultApiFp(configuration).valorantV1LifetimeMmrHistoryAffinityNameTagGet(affinity, name, tag, page, size, options)(fetch, basePath);
        },
        /**
         * Get mmr details
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any) {
            return DefaultApiFp(configuration).valorantV1MmrAffinityNameTagGet(name, tag, affinity, options)(fetch, basePath);
        },
        /**
         * Get MMR History
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1MmrHistoryAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any) {
            return DefaultApiFp(configuration).valorantV1MmrHistoryAffinityNameTagGet(name, tag, affinity, options)(fetch, basePath);
        },
        /**
         * Get a list of all premier conferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierConferencesGet(options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierConferencesGet(options)(fetch, basePath);
        },
        /**
         * Get a combined leaderboard in the conference, sorted by ranking in that div
         * @param {Affinities} affinity 
         * @param {PremierConferences} conference 
         * @param {number} division 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityConferenceDivisionGet(affinity: Affinities, conference: PremierConferences, division: number, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierLeaderboardAffinityConferenceDivisionGet(affinity, conference, division, options)(fetch, basePath);
        },
        /**
         * Get a combined leaderboard in the conference, sorted by div and ranking
         * @param {Affinities} affinity 
         * @param {PremierConferences} conference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityConferenceGet(affinity: Affinities, conference: PremierConferences, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierLeaderboardAffinityConferenceGet(affinity, conference, options)(fetch, basePath);
        },
        /**
         * Get a combined leaderboard in the affinity, sorted by div and ranking
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierLeaderboardAffinityGet(affinity: Affinities, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierLeaderboardAffinityGet(affinity, options)(fetch, basePath);
        },
        /**
         * Search for current active premier teams
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {number} [division] 
         * @param {PremierConferences} [conference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierSearchGet(name?: string, tag?: string, division?: number, conference?: PremierConferences, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierSearchGet(name, tag, division, conference, options)(fetch, basePath);
        },
        /**
         * Get a list of all premier seasons
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierSeasonsAffinityGet(affinity: Affinities, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierSeasonsAffinityGet(affinity, options)(fetch, basePath);
        },
        /**
         * Get details about a premier team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamIdGet(teamId: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierTeamIdGet(teamId, options)(fetch, basePath);
        },
        /**
         * Get match history of a premier team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamIdHistoryGet(teamId: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierTeamIdHistoryGet(teamId, options)(fetch, basePath);
        },
        /**
         * Get details about a premier team
         * @param {string} teamName 
         * @param {string} teamTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamNameTeamTagGet(teamName: string, teamTag: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierTeamNameTeamTagGet(teamName, teamTag, options)(fetch, basePath);
        },
        /**
         * Get match history of a premier team
         * @param {string} teamName 
         * @param {string} teamTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1PremierTeamNameTeamTagHistoryGet(teamName: string, teamTag: string, options?: any) {
            return DefaultApiFp(configuration).valorantV1PremierTeamNameTeamTagHistoryGet(teamName, teamTag, options)(fetch, basePath);
        },
        /**
         * Get a list of all available queues and their metadata
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1QueueStatusAffinityGet(affinity: Affinities, options?: any) {
            return DefaultApiFp(configuration).valorantV1QueueStatusAffinityGet(affinity, options)(fetch, basePath);
        },
        /**
         * Get unchanged response from the valorant api
         * @param {any} body Post body to receive data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1RawPost(body: any, options?: any) {
            return DefaultApiFp(configuration).valorantV1RawPost(body, options)(fetch, basePath);
        },
        /**
         * Server status
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StatusAffinityGet(affinity: Affinities, options?: any) {
            return DefaultApiFp(configuration).valorantV1StatusAffinityGet(affinity, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StoreFeaturedGet(options?: any) {
            return DefaultApiFp(configuration).valorantV1StoreFeaturedGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1StoreOffersGet(options?: any) {
            return DefaultApiFp(configuration).valorantV1StoreOffersGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1VersionAffinityGet(options?: any) {
            return DefaultApiFp(configuration).valorantV1VersionAffinityGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV1WebsiteCountryCodeGet(options?: any) {
            return DefaultApiFp(configuration).valorantV1WebsiteCountryCodeGet(options)(fetch, basePath);
        },
        /**
         * Get MMR Details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {Seasons} [season] Available for v2 MMR
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, season?: Seasons, options?: any) {
            return DefaultApiFp(configuration).valorantV2ByPuuidMmrAffinityPuuidGet(affinity, puuid, season, options)(fetch, basePath);
        },
        /**
         * Get Leaderboard
         * @param {Affinities} affinity 
         * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
         * @param {Seasons} [season] Returns the leaderboard for a specific season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options?: any) {
            return DefaultApiFp(configuration).valorantV2LeaderboardAffinityGet(affinity, puuid, name, tag, season, options)(fetch, basePath);
        },
        /**
         * Get Match Deatils
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2MatchMatchIdGet(matchId: string, options?: any) {
            return DefaultApiFp(configuration).valorantV2MatchMatchIdGet(matchId, options)(fetch, basePath);
        },
        /**
         * Get mmr details
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {Seasons} [season] Available for v2 mmr only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, season?: Seasons, options?: any) {
            return DefaultApiFp(configuration).valorantV2MmrAffinityNameTagGet(name, tag, affinity, season, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2StoreFeaturedGet(options?: any) {
            return DefaultApiFp(configuration).valorantV2StoreFeaturedGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV2StoreOffersGet(options?: any) {
            return DefaultApiFp(configuration).valorantV2StoreOffersGet(options)(fetch, basePath);
        },
        /**
         * Get account details
         * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
         * @param {string} puuid PUUID of the user
         * @param {ModesApi} [mode] 
         * @param {Maps} [map] Available for v3 matches
         * @param {number} [size] Available for v3 matches (how many matches should be returned)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV3ByPuuidMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, size?: number, options?: any) {
            return DefaultApiFp(configuration).valorantV3ByPuuidMatchesAffinityPuuidGet(affinity, puuid, mode, map, size, options)(fetch, basePath);
        },
        /**
         * Get Match History
         * @param {string} name 
         * @param {string} tag 
         * @param {Affinities} affinity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valorantV3MatchesAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any) {
            return DefaultApiFp(configuration).valorantV3MatchesAffinityNameTagGet(name, tag, affinity, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get account details
     * @param {string} name 
     * @param {string} tag 
     * @param {boolean} [force] Force data update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1AccountNameTagGet(name: string, tag: string, force?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1AccountNameTagGet(name, tag, force, options)(this.fetch, this.basePath);
    }

    /**
     * Get account details
     * @param {string} puuid 
     * @param {boolean} [force] Force data update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1ByPuuidAccountPuuidGet(puuid: string, force?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1ByPuuidAccountPuuidGet(puuid, force, options)(this.fetch, this.basePath);
    }

    /**
     * Get lifetime matches
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} puuid PUUID of the user
     * @param {ModesApi} [mode] 
     * @param {Maps} [map] 
     * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
     * @param {number} [size] The amount of returned matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1ByPuuidLifetimeMatchesAffinityPuuidGet(affinity, puuid, mode, map, page, size, options)(this.fetch, this.basePath);
    }

    /**
     * Get lifetime mmr history
     * @param {Affinities} region Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} puuid PUUID of the user
     * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
     * @param {number} [size] The amount of mmr changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet(region: Affinities, puuid: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1ByPuuidLifetimeMmrHistoryRegionPuuidGet(region, puuid, page, size, options)(this.fetch, this.basePath);
    }

    /**
     * Get MMR Details
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} puuid PUUID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1ByPuuidMmrAffinityPuuidGet(affinity, puuid, options)(this.fetch, this.basePath);
    }

    /**
     * Get mmr history
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} puuid PUUID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1ByPuuidMmrHistoryAffinityPuuidGet(affinity: Affinities, puuid: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1ByPuuidMmrHistoryAffinityPuuidGet(affinity, puuid, options)(this.fetch, this.basePath);
    }

    /**
     * Get content
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1ContentGet(locale?: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1ContentGet(locale, options)(this.fetch, this.basePath);
    }

    /**
     * Outputs a 1024x1024 pixel image of the requested crosshair
     * @param {string} [id] ID of the crosshair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1CrosshairGenerateGet(id?: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1CrosshairGenerateGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns esports schedule data
     * @param {string} [region] region of the game (multiple possible)
     * @param {string} [league] league of the game (multiple possible, these also can be highly dynamic if riot announces new tournaments/leagues)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1EsportsScheduleGet(region?: string, league?: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1EsportsScheduleGet(region, league, options)(this.fetch, this.basePath);
    }

    /**
     * Get Leaderboard
     * @param {Affinities} affinity 
     * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
     * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
     * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
     * @param {Seasons} [season] Returns the leaderboard for a specific season
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1LeaderboardAffinityGet(affinity, puuid, name, tag, season, options)(this.fetch, this.basePath);
    }

    /**
     * Get lifetime matches
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} name 
     * @param {string} tag 
     * @param {ModesApi} [mode] 
     * @param {Maps} [map] 
     * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
     * @param {number} [size] The amount of returned matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1LifetimeMatchesAffinityNameTagGet(affinity: Affinities, name: string, tag: string, mode?: ModesApi, map?: Maps, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1LifetimeMatchesAffinityNameTagGet(affinity, name, tag, mode, map, page, size, options)(this.fetch, this.basePath);
    }

    /**
     * Get lifetime mmr changes
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} name 
     * @param {string} tag 
     * @param {number} [page] The page used in pagination (if this is used, the size query parameter also have to exist)
     * @param {number} [size] The amount of returned mmr changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1LifetimeMmrHistoryAffinityNameTagGet(affinity: Affinities, name: string, tag: string, page?: number, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1LifetimeMmrHistoryAffinityNameTagGet(affinity, name, tag, page, size, options)(this.fetch, this.basePath);
    }

    /**
     * Get mmr details
     * @param {string} name 
     * @param {string} tag 
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1MmrAffinityNameTagGet(name, tag, affinity, options)(this.fetch, this.basePath);
    }

    /**
     * Get MMR History
     * @param {string} name 
     * @param {string} tag 
     * @param {Affinities} affinity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1MmrHistoryAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1MmrHistoryAffinityNameTagGet(name, tag, affinity, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all premier conferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierConferencesGet(options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierConferencesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get a combined leaderboard in the conference, sorted by ranking in that div
     * @param {Affinities} affinity 
     * @param {PremierConferences} conference 
     * @param {number} division 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierLeaderboardAffinityConferenceDivisionGet(affinity: Affinities, conference: PremierConferences, division: number, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierLeaderboardAffinityConferenceDivisionGet(affinity, conference, division, options)(this.fetch, this.basePath);
    }

    /**
     * Get a combined leaderboard in the conference, sorted by div and ranking
     * @param {Affinities} affinity 
     * @param {PremierConferences} conference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierLeaderboardAffinityConferenceGet(affinity: Affinities, conference: PremierConferences, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierLeaderboardAffinityConferenceGet(affinity, conference, options)(this.fetch, this.basePath);
    }

    /**
     * Get a combined leaderboard in the affinity, sorted by div and ranking
     * @param {Affinities} affinity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierLeaderboardAffinityGet(affinity: Affinities, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierLeaderboardAffinityGet(affinity, options)(this.fetch, this.basePath);
    }

    /**
     * Search for current active premier teams
     * @param {string} [name] 
     * @param {string} [tag] 
     * @param {number} [division] 
     * @param {PremierConferences} [conference] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierSearchGet(name?: string, tag?: string, division?: number, conference?: PremierConferences, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierSearchGet(name, tag, division, conference, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all premier seasons
     * @param {Affinities} affinity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierSeasonsAffinityGet(affinity: Affinities, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierSeasonsAffinityGet(affinity, options)(this.fetch, this.basePath);
    }

    /**
     * Get details about a premier team
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierTeamIdGet(teamId: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierTeamIdGet(teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Get match history of a premier team
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierTeamIdHistoryGet(teamId: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierTeamIdHistoryGet(teamId, options)(this.fetch, this.basePath);
    }

    /**
     * Get details about a premier team
     * @param {string} teamName 
     * @param {string} teamTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierTeamNameTeamTagGet(teamName: string, teamTag: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierTeamNameTeamTagGet(teamName, teamTag, options)(this.fetch, this.basePath);
    }

    /**
     * Get match history of a premier team
     * @param {string} teamName 
     * @param {string} teamTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1PremierTeamNameTeamTagHistoryGet(teamName: string, teamTag: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1PremierTeamNameTeamTagHistoryGet(teamName, teamTag, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of all available queues and their metadata
     * @param {Affinities} affinity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1QueueStatusAffinityGet(affinity: Affinities, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1QueueStatusAffinityGet(affinity, options)(this.fetch, this.basePath);
    }

    /**
     * Get unchanged response from the valorant api
     * @param {any} body Post body to receive data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1RawPost(body: any, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1RawPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Server status
     * @param {Affinities} affinity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1StatusAffinityGet(affinity: Affinities, options?: any) {
        return DefaultApiFp(this.configuration).valorantV1StatusAffinityGet(affinity, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1StoreFeaturedGet(options?: any) {
        return DefaultApiFp(this.configuration).valorantV1StoreFeaturedGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1StoreOffersGet(options?: any) {
        return DefaultApiFp(this.configuration).valorantV1StoreOffersGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1VersionAffinityGet(options?: any) {
        return DefaultApiFp(this.configuration).valorantV1VersionAffinityGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV1WebsiteCountryCodeGet(options?: any) {
        return DefaultApiFp(this.configuration).valorantV1WebsiteCountryCodeGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get MMR Details
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} puuid PUUID of the user
     * @param {Seasons} [season] Available for v2 MMR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV2ByPuuidMmrAffinityPuuidGet(affinity: Affinities, puuid: string, season?: Seasons, options?: any) {
        return DefaultApiFp(this.configuration).valorantV2ByPuuidMmrAffinityPuuidGet(affinity, puuid, season, options)(this.fetch, this.basePath);
    }

    /**
     * Get Leaderboard
     * @param {Affinities} affinity 
     * @param {string} [puuid] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
     * @param {string} [name] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
     * @param {string} [tag] Note that you can only filter by puuid or name and tag, both at the same time is logically not possible
     * @param {Seasons} [season] Returns the leaderboard for a specific season
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV2LeaderboardAffinityGet(affinity: Affinities, puuid?: string, name?: string, tag?: string, season?: Seasons, options?: any) {
        return DefaultApiFp(this.configuration).valorantV2LeaderboardAffinityGet(affinity, puuid, name, tag, season, options)(this.fetch, this.basePath);
    }

    /**
     * Get Match Deatils
     * @param {string} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV2MatchMatchIdGet(matchId: string, options?: any) {
        return DefaultApiFp(this.configuration).valorantV2MatchMatchIdGet(matchId, options)(this.fetch, this.basePath);
    }

    /**
     * Get mmr details
     * @param {string} name 
     * @param {string} tag 
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {Seasons} [season] Available for v2 mmr only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV2MmrAffinityNameTagGet(name: string, tag: string, affinity: Affinities, season?: Seasons, options?: any) {
        return DefaultApiFp(this.configuration).valorantV2MmrAffinityNameTagGet(name, tag, affinity, season, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV2StoreFeaturedGet(options?: any) {
        return DefaultApiFp(this.configuration).valorantV2StoreFeaturedGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV2StoreOffersGet(options?: any) {
        return DefaultApiFp(this.configuration).valorantV2StoreOffersGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get account details
     * @param {Affinities} affinity Choose from ap, br, eu, kr, latam, na (br and latam will be internally converted to na)
     * @param {string} puuid PUUID of the user
     * @param {ModesApi} [mode] 
     * @param {Maps} [map] Available for v3 matches
     * @param {number} [size] Available for v3 matches (how many matches should be returned)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV3ByPuuidMatchesAffinityPuuidGet(affinity: Affinities, puuid: string, mode?: ModesApi, map?: Maps, size?: number, options?: any) {
        return DefaultApiFp(this.configuration).valorantV3ByPuuidMatchesAffinityPuuidGet(affinity, puuid, mode, map, size, options)(this.fetch, this.basePath);
    }

    /**
     * Get Match History
     * @param {string} name 
     * @param {string} tag 
     * @param {Affinities} affinity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public valorantV3MatchesAffinityNameTagGet(name: string, tag: string, affinity: Affinities, options?: any) {
        return DefaultApiFp(this.configuration).valorantV3MatchesAffinityNameTagGet(name, tag, affinity, options)(this.fetch, this.basePath);
    }

}
